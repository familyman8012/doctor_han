#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
import re
from dataclasses import dataclass
from pathlib import Path
from typing import Optional


@dataclass(frozen=True)
class WriteResult:
    path: Path
    status: str  # created|updated|unchanged|skipped


GENERATED_NOTICE = "<!-- GENERATED by .claude/scripts/refresh.py; DO NOT EDIT BY HAND -->"


def find_repo_root(start: Path) -> Path:
    for candidate in [start, *start.parents]:
        if (candidate / ".git").exists():
            return candidate
    raise SystemExit(f"Could not find repo root from: {start}")


def read_text(path: Path) -> str:
    return path.read_text(encoding="utf-8")


def normalize_trailing_newline(text: str) -> str:
    return text if text.endswith("\n") else f"{text}\n"


def write_text_if_changed(*, path: Path, content: str, apply: bool) -> WriteResult:
    content = normalize_trailing_newline(content)

    if path.exists():
        existing = read_text(path)
        if existing == content:
            return WriteResult(path=path, status="unchanged")
        if not apply:
            return WriteResult(path=path, status="skipped")
        path.parent.mkdir(parents=True, exist_ok=True)
        path.write_text(content, encoding="utf-8")
        return WriteResult(path=path, status="updated")

    if not apply:
        return WriteResult(path=path, status="skipped")
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content, encoding="utf-8")
    return WriteResult(path=path, status="created")


def load_json(path: Path) -> dict:
    return json.loads(read_text(path))


def render_template(template: str, values: dict[str, str]) -> str:
    rendered = template
    for key, value in values.items():
        rendered = rendered.replace(f"{{{{{key}}}}}", value)
    return rendered


def make_pnpm_scripts_table(scripts: dict[str, str]) -> str:
    lines: list[str] = []
    lines.append("| Script | Command |")
    lines.append("| --- | --- |")
    for name in sorted(scripts.keys()):
        command = scripts[name].replace("|", "\\|")
        lines.append(f"| `{name}` | `{command}` |")
    return "\n".join(lines)


def _safe_version(value: object | None) -> str:
    if value is None:
        return "(missing)"
    return str(value)


def _count_glob(root: Path, pattern: str) -> int:
    if not root.exists():
        return 0
    return sum(1 for _ in root.rglob(pattern))


def generate_project_facts(*, repo_root: Path, apply: bool) -> WriteResult:
    package_json = repo_root / "app" / "package.json"
    template_path = repo_root / ".claude" / "templates" / "project-facts.md.tmpl"
    out_path = repo_root / ".claude" / "reference" / "_generated" / "project-facts.md"

    if not package_json.exists():
        content = "\n".join(
            [
                GENERATED_NOTICE,
                "",
                "# Project Facts (Generated)",
                "",
                f"- Missing: `{package_json.relative_to(repo_root)}`",
                "",
            ],
        )
        return write_text_if_changed(path=out_path, content=content, apply=apply)

    pkg = load_json(package_json)
    deps: dict[str, str] = pkg.get("dependencies", {}) or {}
    dev_deps: dict[str, str] = pkg.get("devDependencies", {}) or {}
    scripts: dict[str, str] = pkg.get("scripts", {}) or {}

    api_routes_count = _count_glob(repo_root / "app" / "src" / "app" / "api", "route.ts")
    prd_count = _count_glob(repo_root / "app" / "doc" / "domains", "prd.md")
    tsd_count = _count_glob(repo_root / "app" / "doc" / "domains", "tsd.md")
    ui_count = _count_glob(repo_root / "app" / "doc" / "domains", "ui.md")
    migrations_count = _count_glob(repo_root / "app" / "supabase" / "migrations", "*.sql")

    template = (
        read_text(template_path)
        if template_path.exists()
        else "\n".join(
            [
                GENERATED_NOTICE,
                "",
                "# Project Facts (Generated)",
                "",
                "## 핵심 경로",
                "",
                "- 코드: `app/src/`",
                "- API Routes(BFF): `app/src/app/api/**/route.ts`",
                "- 도메인 스펙: `app/doc/domains/**/{prd,tsd,ui}.md`",
                "- DB 마이그레이션: `app/supabase/migrations/*.sql`",
                "",
                "## 버전 (from app/package.json)",
                "",
                "- next: {{NEXT_VERSION}}",
                "- react: {{REACT_VERSION}}",
                "- typescript: {{TYPESCRIPT_VERSION}}",
                "- @supabase/supabase-js: {{SUPABASE_JS_VERSION}}",
                "- supabase(cli): {{SUPABASE_CLI_VERSION}}",
                "- @tanstack/react-query: {{TANSTACK_QUERY_VERSION}}",
                "- zod: {{ZOD_VERSION}}",
                "- eslint: {{ESLINT_VERSION}}",
                "",
                "## 카운트 (레포 스캔 기반)",
                "",
                "- API routes: {{API_ROUTES_COUNT}}",
                "- PRD: {{PRD_COUNT}}",
                "- TSD: {{TSD_COUNT}}",
                "- UI specs: {{UI_COUNT}}",
                "- migrations: {{MIGRATIONS_COUNT}}",
                "",
                "## pnpm scripts (app/package.json)",
                "",
                "{{PNPM_SCRIPTS_TABLE}}",
                "",
                "## Generated References",
                "",
                "- API routes index: `.claude/reference/_generated/api-routes-index.md`",
                "- Domain specs index: `.claude/reference/_generated/domain-specs-index.md`",
                "- Migrations index: `.claude/reference/_generated/migrations-index.md`",
                "",
                "## Refresh",
                "",
                "- Preview: `python3 .claude/scripts/refresh.py`",
                "- Apply: `python3 .claude/scripts/refresh.py --apply`",
                "",
            ],
        )
    )

    content = render_template(
        template,
        {
            "NEXT_VERSION": _safe_version(deps.get("next")),
            "REACT_VERSION": _safe_version(deps.get("react")),
            "TYPESCRIPT_VERSION": _safe_version(dev_deps.get("typescript", deps.get("typescript"))),
            "SUPABASE_JS_VERSION": _safe_version(deps.get("@supabase/supabase-js")),
            "SUPABASE_CLI_VERSION": _safe_version(dev_deps.get("supabase", deps.get("supabase"))),
            "TANSTACK_QUERY_VERSION": _safe_version(deps.get("@tanstack/react-query")),
            "ZOD_VERSION": _safe_version(deps.get("zod", dev_deps.get("zod"))),
            "ESLINT_VERSION": _safe_version(dev_deps.get("eslint", deps.get("eslint"))),
            "API_ROUTES_COUNT": str(api_routes_count),
            "PRD_COUNT": str(prd_count),
            "TSD_COUNT": str(tsd_count),
            "UI_COUNT": str(ui_count),
            "MIGRATIONS_COUNT": str(migrations_count),
            "PNPM_SCRIPTS_TABLE": make_pnpm_scripts_table({k: str(v) for k, v in scripts.items()}),
        },
    )

    return write_text_if_changed(path=out_path, content=content, apply=apply)


def generate_api_routes_index(*, repo_root: Path, apply: bool) -> WriteResult:
    api_root = repo_root / "app" / "src" / "app" / "api"
    out_path = repo_root / ".claude" / "reference" / "_generated" / "api-routes-index.md"

    routes = sorted(api_root.rglob("route.ts")) if api_root.exists() else []

    rows: list[tuple[str, str]] = []
    for route_file in routes:
        rel = route_file.relative_to(api_root)
        segments = list(rel.parts[:-1])  # drop route.ts

        display_segments: list[str] = []
        for segment in segments:
            # Next.js route group: (group) 는 URL 세그먼트에 포함되지 않음
            if segment.startswith("(") and segment.endswith(")"):
                continue

            m = re.fullmatch(r"\[\[\.{3}(.+)\]\]", segment)  # [[...slug]]
            if m:
                display_segments.append(f":{m.group(1)}*?")
                continue

            m = re.fullmatch(r"\[\.{3}(.+)\]", segment)  # [...slug]
            if m:
                display_segments.append(f":{m.group(1)}*")
                continue

            m = re.fullmatch(r"\[(.+)\]", segment)  # [id]
            if m:
                display_segments.append(f":{m.group(1)}")
                continue

            display_segments.append(segment)

        route_path = "/api" + ("" if not display_segments else "/" + "/".join(display_segments))
        rows.append((route_path, str(route_file.relative_to(repo_root))))

    lines: list[str] = []
    lines.append(GENERATED_NOTICE)
    lines.append("")
    lines.append("# API Routes Index")
    lines.append("")
    lines.append(f"- Source: `{api_root.relative_to(repo_root)}`")
    lines.append("- Refresh: `python3 .claude/scripts/refresh.py --apply`")
    lines.append("")
    lines.append("| Route | Handler |")
    lines.append("| --- | --- |")
    for route_path, handler in sorted(rows, key=lambda x: x[0]):
        lines.append(f"| `{route_path}` | `{handler}` |")
    lines.append("")

    return write_text_if_changed(path=out_path, content="\n".join(lines), apply=apply)


def _domain_feature_key(*, domains_root: Path, spec_dir: Path) -> str:
    rel = spec_dir.relative_to(domains_root)
    return str(rel).replace("\\", "/")


def generate_domain_specs_index(*, repo_root: Path, apply: bool) -> WriteResult:
    domains_root = repo_root / "app" / "doc" / "domains"
    out_path = repo_root / ".claude" / "reference" / "_generated" / "domain-specs-index.md"

    if not domains_root.exists():
        return write_text_if_changed(
            path=out_path,
            content="\n".join(
                [
                    GENERATED_NOTICE,
                    "",
                    "# Domain Specs Index",
                    "",
                    f"- Source missing: `{domains_root.relative_to(repo_root)}`",
                    "- Refresh: `python3 .claude/scripts/refresh.py --apply`",
                    "",
                ],
            ),
            apply=apply,
        )

    by_feature: dict[str, dict[str, str]] = {}

    for filename, key in [("prd.md", "prd"), ("tsd.md", "tsd"), ("ui.md", "ui")]:
        for spec in domains_root.rglob(filename):
            feature_key = _domain_feature_key(domains_root=domains_root, spec_dir=spec.parent)
            by_feature.setdefault(feature_key, {})
            by_feature[feature_key][key] = str(spec.relative_to(repo_root))

    def cell(path: str | None) -> str:
        return f"`{path}`" if path else "-"

    lines: list[str] = []
    lines.append(GENERATED_NOTICE)
    lines.append("")
    lines.append("# Domain Specs Index")
    lines.append("")
    lines.append(f"- Source: `{domains_root.relative_to(repo_root)}`")
    lines.append("- Refresh: `python3 .claude/scripts/refresh.py --apply`")
    lines.append("")
    lines.append("| Domain/Feature | PRD | TSD | UI |")
    lines.append("| --- | --- | --- | --- |")

    for feature_key in sorted(by_feature.keys()):
        specs = by_feature[feature_key]
        lines.append(
            "| "
            + f"`{feature_key}`"
            + " | "
            + cell(specs.get("prd"))
            + " | "
            + cell(specs.get("tsd"))
            + " | "
            + cell(specs.get("ui"))
            + " |"
        )

    lines.append("")
    return write_text_if_changed(path=out_path, content="\n".join(lines), apply=apply)


def generate_migrations_index(*, repo_root: Path, apply: bool) -> WriteResult:
    migrations_root = repo_root / "app" / "supabase" / "migrations"
    out_path = repo_root / ".claude" / "reference" / "_generated" / "migrations-index.md"

    migrations = sorted(migrations_root.glob("*.sql")) if migrations_root.exists() else []

    lines: list[str] = []
    lines.append(GENERATED_NOTICE)
    lines.append("")
    lines.append("# Migrations Index")
    lines.append("")
    lines.append(f"- Source: `{migrations_root.relative_to(repo_root)}`")
    lines.append("- Refresh: `python3 .claude/scripts/refresh.py --apply`")
    lines.append("")
    lines.append("| Migration | File |")
    lines.append("| --- | --- |")
    for migration in migrations:
        rel = migration.relative_to(repo_root)
        lines.append(f"| `{migration.name}` | `{rel}` |")
    lines.append("")

    return write_text_if_changed(path=out_path, content="\n".join(lines), apply=apply)


def main() -> int:
    parser = argparse.ArgumentParser(
        description="(Medihub) 생성 문서(팩트/인덱스)를 레포 상태 기준으로 동기화합니다.",
    )
    parser.add_argument(
        "--apply",
        action="store_true",
        help="실제로 파일을 갱신합니다. 기본은 프리뷰(변경 없음)입니다.",
    )
    args = parser.parse_args()

    # 이 스크립트는 "git root"가 아니라, `.claude/`가 존재하는 프로젝트 루트(web/)를 기준으로 동작해야 합니다.
    # (monorepo에서 git root와 패키지 루트가 다를 수 있음)
    script_path = Path(__file__).resolve()
    repo_root: Optional[Path] = None
    for candidate in [script_path.parent, *script_path.parent.parents]:
        if (candidate / ".claude").is_dir():
            repo_root = candidate
            break
    if repo_root is None:
        raise SystemExit(f"Could not find project root containing `.claude/` from: {script_path}")
    results: list[WriteResult] = []

    results.append(generate_project_facts(repo_root=repo_root, apply=args.apply))
    results.append(generate_api_routes_index(repo_root=repo_root, apply=args.apply))
    results.append(generate_domain_specs_index(repo_root=repo_root, apply=args.apply))
    results.append(generate_migrations_index(repo_root=repo_root, apply=args.apply))

    changed = [r for r in results if r.status in {"created", "updated"}]
    skipped = [r for r in results if r.status == "skipped"]

    print("refresh.py 결과")
    for r in results:
        rel = r.path.relative_to(repo_root)
        print(f"- {r.status}: {rel}")

    if not args.apply and (changed or skipped):
        print("")
        print("프리뷰 모드입니다. 실제 갱신은 다음을 실행하세요:")
        print("  python3 .claude/scripts/refresh.py --apply")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
