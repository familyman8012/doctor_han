#!/usr/bin/env python3
from __future__ import annotations

import argparse
import csv
import json
import re
import sys
from collections import defaultdict
from dataclasses import dataclass
from pathlib import Path


@dataclass(frozen=True)
class WriteResult:
    path: Path
    status: str  # created|updated|unchanged|skipped


GENERATED_NOTICE = "<!-- GENERATED by .claude/scripts/refresh.py; DO NOT EDIT BY HAND -->"


def find_repo_root(start: Path) -> Path:
    for candidate in [start, *start.parents]:
        if (candidate / ".git").exists():
            return candidate
    raise SystemExit(f"Could not find repo root from: {start}")


def read_text(path: Path) -> str:
    return path.read_text(encoding="utf-8")


def normalize_trailing_newline(text: str) -> str:
    return text if text.endswith("\n") else f"{text}\n"


def write_text_if_changed(*, path: Path, content: str, apply: bool) -> WriteResult:
    content = normalize_trailing_newline(content)

    if path.exists():
        existing = read_text(path)
        if existing == content:
            return WriteResult(path=path, status="unchanged")
        if not apply:
            return WriteResult(path=path, status="skipped")
        path.parent.mkdir(parents=True, exist_ok=True)
        path.write_text(content, encoding="utf-8")
        return WriteResult(path=path, status="updated")

    if not apply:
        return WriteResult(path=path, status="skipped")
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content, encoding="utf-8")
    return WriteResult(path=path, status="created")


def load_json(path: Path) -> dict:
    return json.loads(read_text(path))


def render_template(template: str, values: dict[str, str]) -> str:
    rendered = template
    for key, value in values.items():
        rendered = rendered.replace(f"{{{{{key}}}}}", value)
    return rendered


def make_pnpm_scripts_table(scripts: dict[str, str]) -> str:
    lines: list[str] = []
    lines.append("| Script | Command |")
    lines.append("| --- | --- |")
    for name in sorted(scripts.keys()):
        command = scripts[name].replace("|", "\\|")
        lines.append(f"| `{name}` | `{command}` |")
    return "\n".join(lines)


def generate_project_facts(*, repo_root: Path, apply: bool) -> WriteResult:
    package_json = repo_root / "app" / "package.json"
    template_path = repo_root / ".claude" / "templates" / "project-facts.md.tmpl"

    if not package_json.exists():
        content = "\n".join(
            [
                GENERATED_NOTICE,
                "",
                "# Project Facts (Generated)",
                "",
                f"- Missing: `{package_json.relative_to(repo_root)}`",
                "",
            ],
        )
        return write_text_if_changed(
            path=repo_root / ".claude" / "reference" / "_generated" / "project-facts.md",
            content=content,
            apply=apply,
        )

    pkg = load_json(package_json)
    deps = pkg.get("dependencies", {}) or {}
    dev_deps = pkg.get("devDependencies", {}) or {}
    scripts = pkg.get("scripts", {}) or {}

    template = (
        read_text(template_path)
        if template_path.exists()
        else "\n".join(
            [
                GENERATED_NOTICE,
                "",
                "# Project Facts (Generated)",
                "",
                "## App Root",
                "",
                "- App lives in `app/`",
                "- Run scripts from app: `cd app && pnpm ...`",
                "",
                "## Versions (from app/package.json)",
                "",
                "- next: {{NEXT_VERSION}}",
                "- react: {{REACT_VERSION}}",
                "- typescript: {{TYPESCRIPT_VERSION}}",
                "",
                "## pnpm scripts (app/package.json)",
                "",
                "{{PNPM_SCRIPTS_TABLE}}",
                "",
                "## Generated References",
                "",
                "- API routes: `.claude/reference/_generated/api-routes-index.md`",
                "- Domain PRDs: `.claude/reference/_generated/domain-prds-index.md`",
                "- TODO open items: `.claude/reference/_generated/todo-open-items.md`",
                "- test.csv feature map: `.claude/reference/_generated/test-csv-feature-map.md`",
                "",
            ],
        )
    )

    content = render_template(
        template,
        {
            "NEXT_VERSION": str(deps.get("next", "(missing)")),
            "REACT_VERSION": str(deps.get("react", "(missing)")),
            "TYPESCRIPT_VERSION": str(dev_deps.get("typescript", deps.get("typescript", "(missing)"))),
            "PNPM_SCRIPTS_TABLE": make_pnpm_scripts_table({k: str(v) for k, v in scripts.items()}),
        },
    )

    return write_text_if_changed(
        path=repo_root / ".claude" / "reference" / "_generated" / "project-facts.md",
        content=content,
        apply=apply,
    )


def generate_api_routes_index(*, repo_root: Path, apply: bool) -> WriteResult:
    api_root = repo_root / "app" / "src" / "app" / "api"
    routes = sorted(api_root.rglob("route.ts")) if api_root.exists() else []

    rows: list[tuple[str, str]] = []
    for route_file in routes:
        rel = route_file.relative_to(api_root)
        segments = list(rel.parts[:-1])  # drop route.ts
        display_segments: list[str] = []
        for segment in segments:
            # Next.js route group: (group) 는 URL 세그먼트에 포함되지 않음
            if segment.startswith("(") and segment.endswith(")"):
                continue

            m = re.fullmatch(r"\[\[\.{3}(.+)\]\]", segment)  # [[...slug]]
            if m:
                display_segments.append(f":{m.group(1)}*?")
                continue

            m = re.fullmatch(r"\[\.{3}(.+)\]", segment)  # [...slug]
            if m:
                display_segments.append(f":{m.group(1)}*")
                continue

            m = re.fullmatch(r"\[(.+)\]", segment)  # [id]
            if m:
                display_segments.append(f":{m.group(1)}")
                continue

            display_segments.append(segment)

        route_path = "/api" + ("" if not display_segments else "/" + "/".join(display_segments))
        rows.append((route_path, str(route_file.relative_to(repo_root))))

    lines: list[str] = []
    lines.append(GENERATED_NOTICE)
    lines.append("")
    lines.append("# API Routes Index")
    lines.append("")
    lines.append(f"- Source: `{api_root.relative_to(repo_root)}`")
    lines.append("- Refresh: `python3 .claude/scripts/refresh.py --apply`")
    lines.append("")
    lines.append("| Route | Handler |")
    lines.append("| --- | --- |")
    for route_path, handler in sorted(rows, key=lambda x: x[0]):
        lines.append(f"| `{route_path}` | `{handler}` |")
    lines.append("")

    return write_text_if_changed(
        path=repo_root / ".claude" / "reference" / "_generated" / "api-routes-index.md",
        content="\n".join(lines),
        apply=apply,
    )


def generate_domain_prds_index(*, repo_root: Path, apply: bool) -> WriteResult:
    domains_root = repo_root / "app" / "doc" / "domains"
    prds = sorted(domains_root.glob("*/prd.md")) if domains_root.exists() else []

    lines: list[str] = []
    lines.append(GENERATED_NOTICE)
    lines.append("")
    lines.append("# Domain PRDs Index")
    lines.append("")
    lines.append(f"- Source: `{domains_root.relative_to(repo_root)}`")
    lines.append("- Refresh: `python3 .claude/scripts/refresh.py --apply`")
    lines.append("")
    for prd in prds:
        domain = prd.parent.name
        lines.append(f"- `{domain}`: `{prd.relative_to(repo_root)}`")
    lines.append("")

    return write_text_if_changed(
        path=repo_root / ".claude" / "reference" / "_generated" / "domain-prds-index.md",
        content="\n".join(lines),
        apply=apply,
    )


def _domain_feature_key(*, domains_root: Path, spec_dir: Path) -> str:
    rel = spec_dir.relative_to(domains_root)
    return str(rel).replace("\\", "/")


def generate_domain_specs_index(*, repo_root: Path, apply: bool) -> WriteResult:
    domains_root = repo_root / "app" / "doc" / "domains"
    out_path = repo_root / ".claude" / "reference" / "_generated" / "domain-specs-index.md"

    if not domains_root.exists():
        return write_text_if_changed(
            path=out_path,
            content="\n".join(
                [
                    GENERATED_NOTICE,
                    "",
                    "# Domain Specs Index",
                    "",
                    f"- Source missing: `{domains_root.relative_to(repo_root)}`",
                    "- Refresh: `python3 .claude/scripts/refresh.py --apply`",
                    "",
                ],
            ),
            apply=apply,
        )

    spec_dirs: set[Path] = set()
    for name in ("prd.md", "tsd.md", "ui.md"):
        for spec in domains_root.rglob(name):
            spec_dirs.add(spec.parent)

    def fmt(p: Path) -> str:
        return f"`{p.relative_to(repo_root)}`" if p.exists() else "—"

    rows: list[tuple[str, str, str, str]] = []
    for spec_dir in sorted(spec_dirs):
        key = _domain_feature_key(domains_root=domains_root, spec_dir=spec_dir)
        rows.append(
            (
                key,
                fmt(spec_dir / "prd.md"),
                fmt(spec_dir / "tsd.md"),
                fmt(spec_dir / "ui.md"),
            ),
        )

    lines: list[str] = []
    lines.append(GENERATED_NOTICE)
    lines.append("")
    lines.append("# Domain Specs Index")
    lines.append("")
    lines.append(f"- Source: `{domains_root.relative_to(repo_root)}`")
    lines.append("- Refresh: `python3 .claude/scripts/refresh.py --apply`")
    lines.append("")
    lines.append("| Domain/Feature | PRD | TSD | UI |")
    lines.append("| --- | --- | --- | --- |")
    for key, prd, tsd, ui in sorted(rows, key=lambda x: x[0]):
        lines.append(f"| `{key}` | {prd} | {tsd} | {ui} |")
    lines.append("")

    return write_text_if_changed(path=out_path, content="\n".join(lines), apply=apply)


def generate_migrations_index(*, repo_root: Path, apply: bool) -> WriteResult:
    migrations_root = repo_root / "app" / "supabase" / "migrations"
    out_path = repo_root / ".claude" / "reference" / "_generated" / "migrations-index.md"

    if not migrations_root.exists():
        return write_text_if_changed(
            path=out_path,
            content="\n".join(
                [
                    GENERATED_NOTICE,
                    "",
                    "# Migrations Index",
                    "",
                    f"- Source missing: `{migrations_root.relative_to(repo_root)}`",
                    "- Refresh: `python3 .claude/scripts/refresh.py --apply`",
                    "",
                ],
            ),
            apply=apply,
        )

    migrations = sorted(migrations_root.glob("*.sql"))

    rows: list[tuple[str, str, str, int, int]] = []
    for m in migrations:
        name = m.name
        match = re.fullmatch(r"(\d{14})_(.+)\.sql", name)
        ts = match.group(1) if match else ""
        slug = match.group(2) if match else name

        text = m.read_text(encoding="utf-8", errors="ignore")
        policy_count = len(re.findall(r"\bCREATE\s+POLICY\b", text, flags=re.IGNORECASE))
        rls_enable_count = len(re.findall(r"\bENABLE\s+ROW\s+LEVEL\s+SECURITY\b", text, flags=re.IGNORECASE))

        rows.append((ts, slug, str(m.relative_to(repo_root)), policy_count, rls_enable_count))

    lines: list[str] = []
    lines.append(GENERATED_NOTICE)
    lines.append("")
    lines.append("# Migrations Index")
    lines.append("")
    lines.append(f"- Source: `{migrations_root.relative_to(repo_root)}`")
    lines.append("- Refresh: `python3 .claude/scripts/refresh.py --apply`")
    lines.append("")
    lines.append("## Summary")
    lines.append("")
    lines.append(f"- Migrations: **{len(rows)}**")
    if rows:
        latest = max(rows, key=lambda x: x[0] or "")[2]
        lines.append(f"- Latest: `{latest}`")
    lines.append("")
    lines.append("| Timestamp | Name | File | Policies | RLS Enables |")
    lines.append("| --- | --- | --- | --- | --- |")
    for ts, slug, path, policy_count, rls_enable_count in sorted(rows, key=lambda x: x[0] or x[2]):
        ts_display = ts or "—"
        lines.append(f"| `{ts_display}` | `{slug}` | `{path}` | {policy_count} | {rls_enable_count} |")
    lines.append("")

    return write_text_if_changed(path=out_path, content="\n".join(lines), apply=apply)


def _find_test_csv_header(rows: list[list[str]]) -> dict[str, int]:
    for row in rows:
        if "분류" in row and "기능명" in row:
            return {cell: idx for idx, cell in enumerate(row) if cell}
    raise ValueError("Could not find header row containing '분류' and '기능명'")


def generate_test_csv_feature_map(*, repo_root: Path, apply: bool) -> WriteResult:
    csv_path = repo_root / "app" / "doc" / "test.csv"
    out_path = repo_root / ".claude" / "reference" / "_generated" / "test-csv-feature-map.md"

    if not csv_path.exists():
        return write_text_if_changed(
            path=out_path,
            content="\n".join(
                [
                    GENERATED_NOTICE,
                    "",
                    "# test.csv Feature Map",
                    "",
                    f"- Source missing: `{csv_path.relative_to(repo_root)}`",
                    "- Refresh: `python3 .claude/scripts/refresh.py --apply`",
                    "",
                ],
            ),
            apply=apply,
        )

    with csv_path.open(newline="", encoding="utf-8") as f:
        rows = list(csv.reader(f))

    header = _find_test_csv_header(rows)
    idx_minor = header.get("분류")
    idx_name = header.get("기능명")
    idx_req = header.get("요구사항")
    idx_detail = header.get("상세 요구사항")
    idx_later = header.get("후순위")

    def cell(row: list[str], idx: int | None) -> str:
        if idx is None:
            return ""
        return row[idx].strip() if idx < len(row) else ""

    header_row_index = None
    for i, row in enumerate(rows):
        if "분류" in row and "기능명" in row:
            header_row_index = i
            break
    if header_row_index is None:
        raise ValueError("Could not find header row index")

    last_minor = ""
    by_minor: dict[str, list[tuple[str, str, str]]] = defaultdict(list)
    for row in rows[header_row_index + 1 :]:
        if not any(c.strip() for c in row):
            continue
        minor = cell(row, idx_minor)
        if minor:
            last_minor = minor
        else:
            minor = last_minor

        name = cell(row, idx_name)
        if not name:
            continue

        req = cell(row, idx_req)
        detail = cell(row, idx_detail)
        later = cell(row, idx_later)

        desc_parts = [p for p in [req, detail] if p]
        desc = " — ".join(desc_parts) if desc_parts else ""
        by_minor[minor or "(미분류)"].append((name, desc, later))

    lines: list[str] = []
    lines.append(GENERATED_NOTICE)
    lines.append("")
    lines.append("# test.csv Feature Map (Grouped)")
    lines.append("")
    lines.append(f"- Source: `{csv_path.relative_to(repo_root)}`")
    lines.append("- Refresh: `python3 .claude/scripts/refresh.py --apply`")
    lines.append("")
    lines.append("## Summary")
    lines.append("")
    total = sum(len(v) for v in by_minor.values())
    lines.append(f"- Categories: **{len(by_minor)}**")
    lines.append(f"- Features: **{total}**")
    lines.append("")
    lines.append("## Details")
    lines.append("")
    for minor in sorted(by_minor.keys()):
        items = by_minor[minor]
        lines.append(f"### {minor} ({len(items)})")
        lines.append("")
        for name, desc, later in items:
            suffix = f" (후순위: {later})" if later else ""
            lines.append(f"- {name}{(': ' + desc) if desc else ''}{suffix}")
        lines.append("")

    return write_text_if_changed(
        path=out_path,
        content="\n".join(lines),
        apply=apply,
    )


def generate_todo_open_items(*, repo_root: Path, apply: bool) -> WriteResult:
    todo_path = repo_root / "app" / "doc" / "todo.md"
    out_path = repo_root / ".claude" / "reference" / "_generated" / "todo-open-items.md"

    if not todo_path.exists():
        return write_text_if_changed(
            path=out_path,
            content="\n".join(
                [
                    GENERATED_NOTICE,
                    "",
                    "# TODO Open Items",
                    "",
                    f"- Source missing: `{todo_path.relative_to(repo_root)}`",
                    "- Refresh: `python3 .claude/scripts/refresh.py --apply`",
                    "",
                ],
            ),
            apply=apply,
        )

    lines = todo_path.read_text(encoding="utf-8").splitlines()
    open_items: dict[str, list[tuple[int, str]]] = defaultdict(list)

    current_section = "Uncategorized"
    for i, line in enumerate(lines, start=1):
        if line.startswith("## "):
            current_section = line[3:].strip()
            continue
        if line.startswith("### "):
            current_section = line[4:].strip()
            continue

        if line.startswith("- [ ] "):
            open_items[current_section].append((i, line.replace("- [ ] ", "", 1).strip()))

    out: list[str] = []
    out.append(GENERATED_NOTICE)
    out.append("")
    out.append("# TODO Open Items (from app/doc/todo.md)")
    out.append("")
    out.append(f"- Source: `{todo_path.relative_to(repo_root)}`")
    out.append("- Refresh: `python3 .claude/scripts/refresh.py --apply`")
    out.append("")
    total = sum(len(v) for v in open_items.values())
    out.append("## Summary")
    out.append("")
    out.append(f"- Sections: **{len(open_items)}**")
    out.append(f"- Open items: **{total}**")
    out.append("")
    out.append("## Details")
    out.append("")
    for section in sorted(open_items.keys()):
        items = open_items[section]
        out.append(f"### {section} ({len(items)})")
        out.append("")
        for line_no, text in items:
            out.append(f"- L{line_no}: {text}")
        out.append("")

    return write_text_if_changed(
        path=out_path,
        content="\n".join(out),
        apply=apply,
    )


def main(argv: list[str]) -> int:
    parser = argparse.ArgumentParser(description="Refresh generated Claude docs for this repo.")
    parser.add_argument(
        "--repo-root",
        type=Path,
        default=None,
        help="Repo root path (default: auto-detect by walking up to .git).",
    )
    parser.add_argument(
        "--apply",
        action="store_true",
        help="Actually write files. Without this flag, the script only reports what would change.",
    )
    args = parser.parse_args(argv)

    script_dir = Path(__file__).resolve().parent
    repo_root = find_repo_root(args.repo_root or script_dir)

    results: list[WriteResult] = []
    results.append(generate_project_facts(repo_root=repo_root, apply=args.apply))
    results.append(generate_api_routes_index(repo_root=repo_root, apply=args.apply))
    results.append(generate_domain_prds_index(repo_root=repo_root, apply=args.apply))
    results.append(generate_domain_specs_index(repo_root=repo_root, apply=args.apply))
    results.append(generate_migrations_index(repo_root=repo_root, apply=args.apply))
    results.append(generate_test_csv_feature_map(repo_root=repo_root, apply=args.apply))
    results.append(generate_todo_open_items(repo_root=repo_root, apply=args.apply))

    created = [r for r in results if r.status == "created"]
    updated = [r for r in results if r.status == "updated"]
    unchanged = [r for r in results if r.status == "unchanged"]
    skipped = [r for r in results if r.status == "skipped"]

    def rel(p: Path) -> str:
        try:
            return str(p.relative_to(repo_root))
        except ValueError:
            return str(p)

    print("medihub claude refresh")
    print(f"- repo: {repo_root}")
    print(f"- apply: {args.apply}")
    print("")
    print(f"created: {len(created)} | updated: {len(updated)} | unchanged: {len(unchanged)} | skipped: {len(skipped)}")
    if not args.apply and (created or updated):
        print("")
        print("Run again with --apply to write changes.")
    if created or updated or skipped:
        print("")
        for r in results:
            if r.status == "unchanged":
                continue
            print(f"{r.status:8} {rel(r.path)}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
