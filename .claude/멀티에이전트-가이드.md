# Claude Code 멀티 에이전트 오케스트레이션 가이드 (Medihub)

## 서문

이 문서는 Medihub 레포에서 Claude Code를 활용할 때, `.agents/`와 `.claude/`가 어떻게 함께 작동하는지 설명합니다. 목표는 단순합니다:

- 컨텍스트 오염을 줄이고(장기 작업 품질 유지)
- 스펙/정책 드리프트를 줄이고
- 반복 작업을 표준화해 “같은 실수”를 줄입니다.

### 왜 멀티 에이전트인가?

긴 작업일수록 탐색/분석 출력이 대화 기록을 빠르게 잠식합니다. 그 결과:

1. 컨텍스트 윈도우 소진
2. 압축(compact) → 구체 맥락 손실
3. 반복적/일관성 없는 결과

따라서 “토큰을 많이 쓰는 탐색/계획/리뷰/문서”를 **전문화된 서브 에이전트**에 위임하고, 메인 에이전트는 오케스트레이션과 구현에 집중합니다.

---

## 0) Quick Start: `/workflow` 한 줄

```bash
/workflow vendor/search
```

자동으로 진행되는 단계:

1. PRD/TSD 확인(없으면 작성 유도)
2. 컨텍스트 로드(`/prime`) + `@explorer` 탐색
3. 계획 생성(`/plan-feature`) + `@planner`
4. 실행(`/execute`)
5. 검증(`/validate`)
6. 리뷰(`/code-review`) + `@reviewer`

---

## 1) 아키텍처 개요

### 1.1 폴더 구조

```
doctor_han/
├── CLAUDE.md
├── app/                         # Next.js 앱(pnpm은 여기서 실행)
├── .agents/
│   └── plans/
│       └── templates/
│           ├── feature-plan.md
│           └── bugfix-plan.md
└── .claude/
    ├── README.md
    ├── PRD.md
    ├── 소개.md
    ├── settings.local.json
    ├── agents/
    ├── commands/
    ├── skills/
    ├── hooks/
    ├── scripts/
    └── reference/
        ├── *.md
        └── _generated/
```

### 1.2 2-Layer 문서 전략(드리프트 방지)

| 계층 | 위치 | 관리 방식 | 예시 |
|-----|------|---------|------|
| Manual | `.claude/reference/*.md` | 사람이 직접 유지 | coding-conventions, supabase-patterns |
| Generated | `.claude/reference/_generated/` | `/refresh`로 자동 생성 | project-facts, api-routes-index |

Generated는 “현재 레포 사실”을 보장하기 위한 장치입니다. 수동 문서보다 우선합니다.

---

## 2) PIV 루프 운영 규칙

### 2.1 Prime (컨텍스트 고정)

권장 순서:

1. `/refresh` (팩트/인덱스 최신화)
2. `/prime <domain/feature>` (PRD/TSD + 코드 위치 확인)

### 2.2 Plan (계획은 문서로 남긴다)

- 출력: `.agents/plans/<domain>__<feature>.md`
- 규칙: PRD/TSD에 없는 요구/설계를 plan에 새로 발명하지 않습니다.

### 2.3 Execute (컨텍스트 리셋이 품질을 만든다)

계획을 만든 뒤 “새 세션”에서 실행하는 것을 권장합니다.

- 이유: 계획 수립 과정의 노이즈가 구현 품질을 떨어뜨리기 때문
- 실행: `/execute <plan>`

### 2.4 Validate (기계적으로 pass/fail)

```bash
cd app
pnpm lint
pnpm type-check
pnpm test
pnpm build
```

---

## 3) 서브 에이전트 사용 가이드

### 3.1 `@explorer` (읽기 전용 탐색)

언제 쓰나:

- “어디에 구현되어 있지?” “유사 패턴 찾아줘” “이 기능 영향 범위가 뭐야?”

원칙:

- 파일 수정 금지
- 결과는 “관련 파일 표 + 패턴 요약 + 다음 액션”으로 정리

### 3.2 `@planner` (계획만)

언제 쓰나:

- 기능이 크거나(DB/API/UI가 연동), 변경 범위가 넓을 때

원칙:

- DoR 실패면 plan을 만들지 않음(문서 보강으로 되돌림)
- 1 Task = 1 VALIDATE

### 3.3 `@spec-writer` (문서만)

언제 쓰나:

- PRD/TSD가 없거나, 구현과 문서가 어긋날 때

원칙:

- 추측 금지: 없으면 TODO
- DoR 결과를 PASS/FAIL로 명시

### 3.4 `@reviewer` (읽기 전용 리뷰)

언제 쓰나:

- 커밋/PR 전

우선순위:

1. 정책 위반(Server Action/DB direct/RQ hook/onError)
2. 권한/보안(RLS/guards/service_role)
3. 입력 검증/에러 표준화(withApi)

---

## 4) 리스크 기반 승인 포인트(권장)

자동 진행(승인 생략):

- UI-only 변경
- 단일 파일/단순 리팩터(동일 패턴 유지)
- DB/API/권한 정책 변경 없음

승인 권장(요약 후 확인):

- DB 마이그레이션/Policy(RLS) 변경
- API 엔드포인트 추가/변경
- 인증/인가(guards) 변경
- service_role 사용 범위 변경
- 데이터 손실/대규모 락 위험

---

## 5) 실전 예시

### 5.1 UI-only 개선

```bash
/refresh
/prime vendor/ui
/plan-feature vendor/ui
/execute vendor__ui
/validate
/code-review
```

### 5.2 DB + API 변경

1. `/new-migration <name>` 또는 `cd app && pnpm db:new -- "<name>"`
2. `cd app && pnpm db:migrate`
3. `cd app && pnpm db:gen -- --local`
4. Zod 스키마 갱신(`app/src/lib/schema/*.ts`)
5. API Route 구현(`app/src/app/api/**/route.ts`)
6. `/validate`

---

## 6) 참고 링크

- `.claude/소개.md`
- `.claude/reference/spec-templates.md`
- `.claude/reference/_generated/project-facts.md`

