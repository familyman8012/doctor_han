# Claude Code R&D 종합 가이드
## Skill / Custom Command / Sub-Agent / Hooks 완전 정복

> 이 문서는 Claude Code의 핵심 기능인 **Skills(스킬)**, **Custom Commands(사용자 정의 명령어)**, **Sub-Agents(하위 에이전트)**, **Hooks(훅)**에 대한 R&D 내용을 종합적으로 정리한 것입니다.

---

# 제1부: 서론 - AI 코딩의 새로운 패러다임

## 1.1 에이전틱 엔지니어링의 시대

AI 코딩 어시스턴트를 사용하고 있다면, 아마 그 잠재력의 대부분을 제대로 활용하지 못하고 있을 가능성이 큽니다. 단순히 AI에게 코드를 요청하는 것을 넘어, **시스템적으로 AI와 협업하는 방법**을 익히는 것이 현대 소프트웨어 엔지니어링의 핵심 역량이 되었습니다.

멀티 에이전트 시스템은 단순한 기술 트렌드를 넘어, 현대 소프트웨어 엔지니어링의 패러다임을 근본적으로 바꾸는 전략적 전환점입니다. 여러 전문화된 에이전트가 협력하여 복잡한 문제를 해결하는 이 접근 방식은, 엔지니어가 자동화와 지능의 시대를 선도하는 진정한 **빌더(builder)**로 거듭나기 위한 핵심입니다.

## 1.2 AI 에이전트의 현재 한계

현재 AI 에이전트가 겪고 있는 구체적인 한계는 기업의 생산성에 직접적인 영향을 미칩니다:

| 한계점 | 설명 |
|--------|------|
| **부족한 사전 컨텍스트** | 에이전트는 작업을 시작할 때 중요한 맥락을 선제적으로 파악하지 못함 |
| **전문성 흡수의 어려움** | 조직이 수년간 축적한 고유의 업무 방식, 노하우를 효과적으로 내재화하지 못함 |
| **시간이 지나도 학습하지 못함** | 반복적인 상호작용과 경험을 통해 점진적으로 개선되지 않음 |

'지능'과 '전문성'의 차이를 생각해보면: 300의 IQ를 가진 수학 천재와 수년간의 경험을 쌓은 세무 전문가 중 세금 신고를 누구에게 맡기시겠습니까? 우리는 천재가 세법을 처음부터 재해석하는 것을 원치 않으며, **도메인 전문가가 제공하는 일관되고 신뢰할 수 있는 실행**을 필요로 합니다.

## 1.3 이 문서가 다루는 내용

본 문서는 이러한 한계를 극복하기 위한 다음 기술들을 심층적으로 다룹니다:

1. **AI 코딩 5대 핵심 기법** - PRD 우선 개발, 모듈형 규칙, 명령어화, 컨텍스트 리셋, 시스템 진화
2. **하위 에이전트(Sub-Agents)** - 전문화된 AI 팀 구성과 협업 전략
3. **에이전트 스킬(Skills)** - 재사용 가능한 전문 지식 패키지
4. **Custom Commands & Hooks** - 워크플로우 자동화와 시스템 확장

---

# 제2부: AI 코딩 5대 핵심 기법

## 2.1 PRD 우선 개발: 프로젝트의 '북극성' 만들기

### 개념

AI 코딩 시 가장 흔한 실패 원인 중 하나는 명확한 목표 없이 모호한 지시를 내리는 것입니다. **PRD(Product Requirement Document) 우선 개발**이란, 프로젝트의 전체 작업 범위를 정의하는 단일 마크다운 문서를 만들고, 이를 코딩 에이전트를 위한 '북극성(North Star)'으로 삼는 개발 방식입니다.

### 중요한 이유

| 이점 | 설명 |
|------|------|
| **과부하 방지** | AI 코딩 에이전트는 한 번에 너무 많은 작업을 처리하려 하면 실패하기 쉬움. PRD는 전체 프로젝트를 더 작고 구체적인 기능 단위로 분할 |
| **방향성 제시** | 모든 개발 작업이 최종 목표와 긴밀하게 연결되도록 방향을 제시 |

### 실제 작업 흐름

1. AI와 대화를 통해 만들고 싶은 기능에 대한 계획 수립
2. `/createPRD` 같은 명령어를 사용해 PRD 문서 생성
3. 모든 개발 과정에서 이 PRD를 기준으로 작업 진행
4. `/prime` 명령어로 새 대화 시작 시 PRD를 포함한 핵심 컨텍스트 로드

---

## 2.2 모듈형 규칙 아키텍처: AI의 '컨텍스트 윈도우' 보호하기

### 개념

많은 개발자들이 저지르는 흔한 실수는 모든 규칙을 하나의 거대한 전역 규칙 파일(`claude.md` 등)에 담는 것입니다. **모듈형 규칙 아키텍처**는 규칙을 가벼운 '전역 규칙'과 작업 유형별 '참조 규칙'으로 분리하는 기법입니다.

### 핵심 목표: 컨텍스트 윈도우 보호

컨텍스트 윈도우는 AI의 '단기 기억력'과 같습니다. 이 공간이 관련 없는 규칙들로 가득 차면, 정작 중요한 현재 작업에 집중할 '정신적 여유'가 사라져 성능이 저하됩니다.

### 모듈형 규칙 파일 구조

```
.claude/
├── claude.md              # 전역 규칙 (간결하게 유지)
└── reference/
    ├── api_rules.md       # API 개발 시에만 참조
    ├── frontend_rules.md  # 프론트엔드 작업 시에만 참조
    └── deployment.md      # 배포 관련 규칙
```

**전역 규칙 파일 (claude.md)**
- 테스트 전략, 기술 스택, 로깅 표준 등 어떤 작업을 하든 항상 적용되는 핵심 규칙만 간결하게 유지
- 참조 규칙 파일들의 경로를 명시

**참조 규칙 파일**
- API 엔드포인트 개발, 프론트엔드 등 특정 작업에 대한 상세하고 긴 규칙들 보관
- AI는 해당 작업을 할 때만 이 파일을 참조

---

## 2.3 모든 것의 명령어화: 반복 작업을 '나만의 워크플로우'로 만들기

### 개념

**명령어화(Commandifying)**란, AI 에이전트에게 두 번 이상 입력하는 프롬프트가 있다면 그것을 재사용 가능한 '명령어'로 만드는 것을 의미합니다. 이 명령어는 본질적으로, 반복적으로 입력하던 긴 프롬프트를 `/plan`이나 `/commit`처럼 짧은 키워드로 대체할 수 있게 해주는 마크다운 문서입니다.

### 핵심 장점

| 장점 | 설명 |
|------|------|
| **시간 절약** | 반복적인 프롬프트를 명령어로 만들어두면, 수천 번의 키 입력 절약 |
| **공유와 표준화** | 잘 만들어진 명령어는 팀 전체의 생산성을 높이는 워크플로우가 됨 |

### 명령어로 만들 수 있는 작업들

- **Git 커밋 메시지 생성** (`/commit`)
- **PRD 초안 작성** (`/createPRD`)
- **프로젝트 컨텍스트 로딩** (`/prime`)
- **기능 구현 계획 수립 및 실행** (`/plan`, `/execute`)
- **코드 검증** (`/validate`)
- **코드 리뷰** (`/code-review`)

### 명령어 파일 위치

```
.claude/
└── commands/
    ├── commit.md
    ├── prime.md
    ├── plan-feature.md
    ├── execute.md
    └── validate.md
```

---

## 2.4 컨텍스트 리셋: AI에게 '깨끗한 작업 공간' 선물하기

### 개념

**컨텍스트 리셋**은 기능 구현을 위한 '계획' 단계와 실제 코드를 작성하는 '실행' 단계 사이에 대화창을 완전히 초기화하는 기법입니다.

### 중요한 이유

계획 단계에서 나눈 불필요한 이전 대화 내용을 모두 지우면, AI는 오직 최종적으로 확정된 계획서에만 모든 컨텍스트를 집중할 수 있습니다. 이는 코드를 추론하고 스스로 검증하는 능력을 크게 향상시킵니다.

### 2단계 프로세스

```
┌─────────────────────────────────────────────────────────┐
│  1단계: 계획 단계                                        │
│  ─────────────────                                      │
│  AI와의 긴 대화를 통해 기능 구현에 필요한 모든 컨텍스트가  │
│  담긴 상세한 마크다운 '계획 문서'를 최종적으로 출력        │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
                    [/clear 명령어]
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│  2단계: 실행 단계                                        │
│  ─────────────────                                      │
│  대화창을 완전히 비운 뒤, AI에게 오직 방금 만든           │
│  '계획 문서' 하나만을 제공하여 코드 작성 시작             │
└─────────────────────────────────────────────────────────┘
```

---

## 2.5 시스템 진화: 버그를 '성장의 기회'로 바꾸기

### 개념

이 기법은 단순히 버그를 수정하는 것을 넘어, **"버그를 허용한 시스템을 수정하는 것"**이라는 마음가짐의 전환을 의미합니다. 모든 버그는 코딩 에이전트를 더 똑똑하게 만들 절호의 기회입니다.

### 실제 적용 예시

| 문제점 (Bug) | 시스템 개선 (System Fix) |
|-------------|------------------------|
| AI가 잘못된 import 스타일을 사용함 | 전역 규칙 파일에 올바른 import 스타일에 대한 한 줄 규칙 추가 |
| AI가 테스트 실행을 자꾸 잊어버림 | 실행 계획 템플릿에 '테스트' 섹션을 필수로 포함하도록 업데이트 |
| AI가 인증 흐름을 이해하지 못함 | 인증 로직을 설명하는 새 참조 문서 작성 및 전역 규칙 수정 |

### 실제 대화 예시

```
"클로드, 애플리케이션에서 XYZ가 제대로 작동하지 않는 것을
발견해서 제가 직접 수정했습니다. 우리가 사용했던 명령어와
규칙들을 다시 검토해서, 이 문제가 다시 발생하지 않도록
프로세스나 규칙을 어떻게 개선할 수 있을지 제안해주세요."
```

### 핵심 가치

5가지 기법—PRD 우선 개발, 모듈형 규칙, 명령어화, 컨텍스트 리셋, 시스템 진화—은 각각 독립된 기술이 아닙니다. 이것은 서로 맞물려 돌아가는 강력한 **선순환 구조**입니다:

```
  PRD가 명확한 목적지 설정
            │
            ▼
  모듈형 규칙과 명령어화가 효율적인 엔진 제공
            │
            ▼
  컨텍스트 리셋으로 최고의 집중력으로 작업 실행
            │
            ▼
  시스템 진화로 엔진 자체를 업그레이드
            │
            └──────────────────────────┐
                                       ▼
                              [반복 / 개선]
```

---

# 제3부: 하위 에이전트 (Sub-Agents) 심층 분석

## 3.1 하위 에이전트란?

### 개념 정의

하위 에이전트는 **'각자 명확한 시스템 프롬프트(System Prompt)와 독립된 컨텍스트 창(Context Window)을 가진 전문화된 AI 팀원'**으로 정의됩니다. 이는 모든 종류의 작업을 처리하는 단일 '범용 에이전트(General-purpose Agent)'와는 근본적으로 다릅니다.

```
범용 에이전트가 프로젝트 매니저라면,
하위 에이전트는 프론트엔드 개발자, 백엔드 개발자,
코드 리뷰어 등 각자의 전문 영역을 책임지는 핵심 팀원
```

### 왜 필요한가? - 컨텍스트 윈도우의 한계

단일 에이전트가 코딩 작업을 수행할 때, 기존 코드베이스를 이해하기 위해 `read file`과 같은 도구를 사용합니다. 분석해야 할 파일의 양이 많거나 내용이 길 경우, 파일의 전체 내용이 대화 기록에 포함되면서 **컨텍스트 윈도우의 80% 이상이 순식간에 소진**될 수 있습니다.

컨텍스트 윈도우가 한계에 도달하면:
1. Claude Code는 '대화 압축(compact conversation)' 명령을 트리거
2. 이전 대화 내용을 요약하면서 **구체적인 맥락을 상실**
3. 일관성 없고 반복적이며 종종 잘못된 결과물 생성

---

## 3.2 정보 흐름과 아키텍처

### 에이전트 계층 구조

| 에이전트 종류 | 역할 | 주요 특징 |
|-------------|------|----------|
| **기본 에이전트 (Primary Agent)** | 오케스트레이터 | • 사용자와 직접 상호작용<br>• 전체 작업의 컨텍스트 유지<br>• 적절한 하위 에이전트에게 작업 위임 |
| **하위 에이전트 (Sub-agent)** | 전문가 | • 특정 전문 분야에 최적화<br>• 독립적이고 격리된 컨텍스트 창<br>• 오직 기본 에이전트에게만 보고 |

### 결정적인 정보 흐름

```
사용자 → 기본 에이전트 → 하위 에이전트 → 기본 에이전트 → 사용자
```

> **핵심 포인트**: "하위 에이전트는 사용자에게 응답하는 것이 아니라 기본 에이전트에게 보고한다"

이는 하위 에이전트의 프롬프트를 설계하는 방식을 완전히 바꿉니다:

| 잘못된 방식 | 올바른 방식 |
|------------|-----------|
| "결과를 요약하고 사용자에게 인사하세요" | "기본 에이전트가 다음 단계를 처리할 수 있도록 상세 보고서를 Markdown 형식으로 생성하시오" |

---

## 3.3 하위 에이전트의 구성 요소

하위 에이전트는 구성 파일을 통해 정의됩니다:

| 요소 | 핵심 기능 및 전략적 중요성 |
|------|-------------------------|
| **agent name** | 에이전트의 고유 식별자(ID) |
| **description** | 주 에이전트가 언제, 어떻게 이 하위 에이전트를 호출할지를 결정하는 핵심 정보. **호출 조건을 제어하는 인터페이스** |
| **tools** | 해당 하위 에이전트가 사용할 수 있는 도구 목록. 권한과 기능 제한 |
| **color** | 에이전트 활동 시 UI에 표시되는 색상 |
| **system prompt** | 하위 에이전트의 최상위 기능, 행동 방식, 목표, 보고서 형식을 정의. 에이전트의 근본적인 성격과 역할을 규정하는 지침서 |

### description과 system prompt의 역할

- **description**: '호출 시점'을 제어
- **system prompt**: '호출된 후의 행동'을 제어

---

## 3.4 흔한 오해와 실패: '구현 에이전트' 모델의 함정

### 직관적이지만 실패하는 접근법

많은 개발자들이 하위 에이전트를 처음 접할 때, 각 전문 분야(프론트엔드, 백엔드)의 에이전트에게 직접 코드 수정을 맡기는 '구현 우선' 접근법을 시도합니다.

### 실패 원인

| 문제점 | 설명 |
|-------|------|
| **컨텍스트 단절** | 각 하위 에이전트의 작업은 완전히 독립된 세션으로 실행. 프론트엔드 에이전트가 방금 수정한 내용이나, 이전에 백엔드 에이전트가 수행한 작업 내역을 전혀 알지 못함 |
| **디버깅의 어려움** | 하위 에이전트가 버그를 발생시켰을 때, 기본 에이전트는 문제의 원인을 파악하기 매우 어려움. "작업을 할당했고, 완료했다고 보고받은 것뿐" |
| **비효율적인 수정 작업** | 버그 수정을 위해 동일한 하위 에이전트를 다시 호출해도, 이전 작업에 대한 컨텍스트가 전혀 없어 처음부터 새로운 작업을 시작하는 것과 같음 |

### 핵심 교훈

> '격리된 세션'이라는 근본적인 한계는 정면으로 돌파해야 할 결함이 아니라, **아키텍처를 통해 우회해야 할 제약 조건**입니다.

---

## 3.5 패러다임 전환: 연구원/기획자(Researcher/Planner) 모델

### 핵심 해법

하위 에이전트를 코드 '구현자'가 아닌, 특정 분야에 고도로 특화된 **'전문 연구원'**으로 간주합니다.

Claude Code 팀의 핵심 엔지니어인 Adam Wolf:
> "하위 에이전트는 **정보를 찾고(looking for information)**, 소량의 요약 정보를 메인 대화 스레드로 다시 제공할 때 가장 잘 작동한다"

### 역할 재정의

| 역할 | 담당 업무 |
|------|----------|
| **연구원 (Researcher)** | 코드베이스 분석, 특정 기능 관련 파일 검색, 외부 정보 참조, 필요한 모든 정보 수집 |
| **기획자 (Planner)** | 연구원이 수집한 정보를 바탕으로 실제 구현을 위한 구체적인 청사진(계획 문서) 작성 |

### 실행 주체의 명확화

```
┌─────────────────────────────────────────────────────────┐
│  핵심 원칙                                               │
│  ─────────                                              │
│  실제 코드 작성 및 수정(구현)은 모든 계획과 컨텍스트를    │
│  전달받은 기본 에이전트가 전담합니다.                     │
└─────────────────────────────────────────────────────────┘
```

### 핵심 이점

| 이점 | 설명 |
|------|------|
| **토큰 효율성 극대화** | 하위 에이전트가 수만 토큰을 사용해도, 상위 에이전트에게는 몇백 토큰의 요약 보고서만 전달 |
| **구현 컨텍스트의 중앙화** | 모든 코드 변경 내역이 상위 에이전트의 대화 기록에 중앙화되어 관리 |
| **디버깅 용이** | 전체 코드베이스에 대한 완전한 이해를 바탕으로 효과적인 대응 가능 |

---

## 3.6 파일 시스템을 활용한 컨텍스트 관리

### 공유 메모리로서의 파일 시스템

파일 시스템을 에이전트 간 '공유 컨텍스트 데이터베이스'로 활용합니다. 이 전략은 모든 에이전트가 읽고 쓸 수 있는 외부의 영구적인 '공유 메모리'를 생성함으로써 '격리된 세션'의 한계에 대응합니다.

### 워크플로우 구성

```
1. 중앙 컨텍스트 파일 생성
   ├── 기본 에이전트가 doc/tasks/context_session.md 생성
   └── 전체 작업의 목표, 현재 상태 등 담음

2. 컨텍스트 파일 읽기
   └── 호출된 하위 에이전트가 가장 먼저 context.md 파일 읽기

3. 연구 및 계획안 작성
   └── 하위 에이전트가 결과물을 별도의 Markdown 파일로 저장
       (예: doc/tasks/implementation_plan.md)

4. 컨텍스트 파일 업데이트
   └── 작업 완료 후 context.md에 작업 내용과 보고서 경로 추가

5. 계획 기반 구현
   └── 기본 에이전트가 계획안 파일을 읽고 직접 코드 구현
```

### 예시 디렉토리 구조

```
doc/
└── tasks/
    ├── context_session.md     # 중앙 컨텍스트 (단일 진실 공급원)
    ├── ui_plan.md             # UI 설계 계획
    ├── api_plan.md            # API 연동 계획
    └── implementation_plan.md # 구현 계획
```

### 기대 효과

- **토큰 사용량 최적화**: 컨텍스트 창에 방대한 파일 내용을 직접 주입하는 것 방지
- **작업 연속성 보장**: 모든 에이전트가 공유된 context.md를 통해 작업 상태 동기화
- **성공률 향상**: 복잡한 프로젝트의 전체 성공률 극적으로 향상

---

## 3.7 오케스트레이션 패턴

### 패턴 1: 선형 체이닝 (Linear Chaining)

하나의 작업 결과가 다음 작업의 입력이 되는 순차적인 워크플로우입니다.

```
프론트엔드 엔지니어 → 코드 리뷰어 → 프론트엔드 엔지니어
       │                  │                │
       ▼                  ▼                ▼
  UI 개선 구현      변경 코드 검토      리뷰 반영 수정
```

**적합한 상황**: 단계가 명확하고 예측 가능한 작업, CI/CD 파이프라인과 같은 결정론적 프로세스

### 패턴 2: 계획 기반 위임 (Plan-Based Delegation)

파일 시스템을 중앙 허브로 사용하여 여러 전문 에이전트가 비동기적으로 협업하는 모델입니다.

```
1. 기본 에이전트 → UI/UX 기획 에이전트 호출
                   └── ui_plan.md 생성

2. 기본 에이전트 ← ui_plan.md 읽고 직접 UI 코드 구현

3. 기본 에이전트 → Vercel AI SDK 연동 에이전트 호출
                   └── api_plan.md 생성

4. 기본 에이전트 ← api_plan.md 읽고 직접 백엔드 구현
```

**적합한 상황**: 각 부분이 독립적으로 계획되고 순차적으로 실행되어야 하는 복잡한 프로젝트

### 호출 방식 비교

| 방식 | 설명 | 사용 사례 |
|------|------|----------|
| **범용 에이전트를 통한 위임** | 자연어로 범용 에이전트에게 지시 | 특정 전문가의 검토가 필요할 때 |
| **직접 호출 (@)** | `@backend-engineer` 형식으로 즉시 할당 | 긴급한 수정, 특정 전문가 개입 필요 시 |
| **자동 오케스트레이션** | 다단계 목표 제시 → AI가 스스로 계획 수립 | 신규 기능 개발, 대규모 리팩토링 |

---

## 3.8 핵심 에이전트 역할 정의 예시

| 에이전트 역할 | 주요 임무 | 권장 도구 설정 |
|-------------|----------|---------------|
| **코드 리뷰어** | 코드 최적화, 리팩토링, 주석 추가 등 코드 품질 보증 | 파일 읽기 전용 (Read only tools) |
| **백엔드 엔지니어** | Next.js 앱 라우터, 서버 액션, 라우트 핸들러 전문 | 모든 도구 접근 허용 |
| **프론트엔드 엔지니어** | React, Tailwind, Shad CN 전문 | 모든 도구 접근 허용 |

### 에이전트 설정 예시

```yaml
# .claude/agents/code-reviewer.yaml
name: code-reviewer
description: |
  코드 최적화, 리팩토링, 주석 추가 등 코드 품질 보증을 책임집니다.
  Next.js, React, TypeScript 기반 풀스택 개발 경험을 가진 전문가.
tools:
  - Read
  - Glob
  - Grep
color: blue
```

---

## 3.9 하위 에이전트의 장점과 한계

### 핵심 장점

| 장점 | 설명 |
|------|------|
| **컨텍스트 보존** | 각 하위 에이전트는 독립적인 컨텍스트 창에서 작동하여 메인 대화 오염 방지 |
| **전문성 강화** | 시스템 프롬프트와 도구를 특정 작업에 맞게 고도로 최적화 |
| **재사용성** | 에이전트 구성 파일은 코드베이스에 저장되어 팀 내 쉽게 공유 가능 |
| **집중력 유지** | 단일 책임 원칙에 따라 하나의 작업에만 집중 |

### 잠재적 한계

| 한계점 | 해결 전략 |
|--------|----------|
| **컨텍스트 이력 부재** | 기본 에이전트가 필요한 모든 정보를 명시적으로 프롬프트에 전달 |
| **디버깅의 어려움** | Claude Code 훅을 활용하여 에이전트 간 프롬프트와 응답을 로그 파일에 기록 |
| **결정 과부하** | 각 에이전트의 description에 명확하고 구체적인 호출 조건 명시 |
| **의존성 결합** | 각 에이전트를 가능한 한 독립적으로 유지, 워크플로우 체인 복잡도 제한 |

---

## 3.10 엔지니어들이 흔히 저지르는 두 가지 실수

### 실수 1: '시스템 프롬프트'를 '사용자 프롬프트'로 오해

하위 에이전트 구성 파일에 작성하는 프롬프트는 사용자가 직접 입력하는 일회성 명령이 아니라, 에이전트의 **근본적인 행동 지침을 정의하는 시스템 프롬프트**입니다.

### 실수 2: 하위 에이전트의 응답 대상을 오해

많은 엔지니어들은 하위 에이전트가 사용자에게 직접 응답한다고 가정합니다. 하지만 하위 에이전트는 **주 에이전트에게 응답**합니다.

---

# 제4부: 에이전트 스킬 (Agent Skills) 완전 가이드

## 4.1 스킬이란?

### 정의

**에이전트 스킬(Agent Skills)**은 Claude에게 특정 분야의 전문 지식을 제공하는 재사용 가능한 '전문 지식 패키지'입니다. 스킬을 통해 범용적인 능력을 가진 Claude는 특정 작업을 능숙하게 처리하는 전문가로 변신할 수 있습니다.

> 스킬은 마치 신입사원을 위해 체계적인 온보딩 가이드를 만드는 것과 같습니다. 신입사원에게 회사의 모든 정보를 한 번에 쏟아붓는 대신, 업무에 필요한 지침서, 참고 자료, 그리고 유용한 도구(스크립트)를 담은 폴더를 건네주는 것입니다.

### 공식 정의

**"구성 가능한 절차적 지식을 패키징한 파일들의 조직화된 컬렉션"** - 가장 단순하게는 하나의 '폴더'

### 왜 스킬이 필요한가?

| 항목 | 스킬 (Skills) | 프롬프트 (Prompts) |
|------|--------------|-------------------|
| 목적 | 특정 영역 전문화 | 일회성 작업 지시 |
| 재사용성 | 한 번 생성 후 자동 사용 | 매 대화마다 반복 제공 |
| 정보량 | 방대한 지식과 코드 포함 가능 | 컨텍스트 창 크기에 제한 |
| 효율성 | 필요시 정보 로드 (점진적 공개) | 모든 정보를 미리 제공 |

---

## 4.2 스킬의 핵심 원리: 점진적 공개 (Progressive Disclosure)

스킬의 가장 중요한 특징은 **점진적 공개(Progressive Disclosure)**라는 정보 로딩 방식입니다. Claude는 스킬의 모든 정보를 한 번에 읽는 것이 아니라, 작업에 필요한 만큼만 단계적으로 불러옵니다.

### 3단계 로딩 구조

```
┌────────────────────────────────────────────────────────────┐
│  레벨 1: 메타데이터 (항상 로드됨)                            │
│  ─────────────────────────────────                        │
│  • 언제: Claude가 시작될 때 항상 로드                        │
│  • 내용: name, description (YAML 프론트매터)                 │
│  • 비용: 각 스킬당 약 100토큰                                │
│  • 역할: 어떤 스킬이 있고, 언제 사용해야 하는지 파악          │
└────────────────────────────────────────────────────────────┘
                            │
                            ▼ (스킬 활성화 시)
┌────────────────────────────────────────────────────────────┐
│  레벨 2: 지침 (필요할 때 로드됨)                              │
│  ─────────────────────────────                             │
│  • 언제: 사용자의 요청이 스킬의 설명과 일치할 때               │
│  • 내용: SKILL.md 본문 (작업 절차, 워크플로우, 모범 사례)       │
│  • 비용: 5,000토큰 이하 권장                                  │
│  • 역할: 핵심적인 지침 제공                                   │
└────────────────────────────────────────────────────────────┘
                            │
                            ▼ (필요에 따라)
┌────────────────────────────────────────────────────────────┐
│  레벨 3: 리소스 및 코드 (필요에 따라 로드됨)                   │
│  ─────────────────────────────────────                     │
│  • 언제: 지침 내에서 특정 파일이 참조될 때                     │
│  • 내용: 파이썬 스크립트, 추가 설명서, DB 스키마, API 문서     │
│  • 비용: 사실상 무제한                                        │
│  • 특징: 코드 스크립트는 실행 후 결과값만 반환 (토큰 절약)      │
└────────────────────────────────────────────────────────────┘
```

### 실제 작동 예시: PDF 처리 스킬

1. **시작**: Claude의 시스템 프롬프트에 `pdf-processing` 스킬의 메타데이터가 로드됨
2. **요청 인식**: 사용자가 "이 PDF에서 텍스트를 추출해서 요약해줘"라고 요청
3. **지침 로드**: Claude가 bash 명령어로 `pdf-skill/SKILL.md` 파일 읽기
4. **선택적 로드**: 현재 요청은 텍스트 추출이므로, 양식 채우기 관련 `FORMS.md`는 읽지 않음
5. **작업 완료**: 필요한 지침만으로 효율적으로 작업 완료

---

## 4.3 스킬 구조와 구성 요소

### 기본 디렉토리 구조

```
skill-directory/
├── SKILL.md           # 필수 - 메인 지침
├── FORMS.md           # 선택 - 양식 채우기 가이드
├── REFERENCE.md       # 선택 - API 참조
├── examples.md        # 선택 - 사용 예시
└── scripts/
    ├── analyze.py     # 유틸리티 스크립트
    ├── validate.py
    └── fill_form.py
```

### SKILL.md 필수 구조

```yaml
---
name: your-skill-name
description: Brief description of what this Skill does and when to use it
---

# Your Skill Name

## Instructions
[Clear, step-by-step guidance for Claude to follow]

## Examples
[Concrete examples of using this Skill]
```

### 필드 요구사항

| 필드 | 요구사항 |
|------|----------|
| `name` | • 최대 64자<br>• 소문자, 숫자, 하이픈만 사용<br>• XML 태그 불가<br>• 예약어("anthropic", "claude") 불가 |
| `description` | • 비어있으면 안 됨<br>• 최대 1024자<br>• XML 태그 불가<br>• 무엇을 하고 언제 사용해야 하는지 포함 |

### 효과적인 description 작성

**좋은 예시:**
```yaml
description: Extract text and tables from PDF files, fill forms, merge documents.
Use when working with PDF files or when the user mentions PDFs, forms, or document extraction.
```

**나쁜 예시:**
```yaml
description: Helps with documents  # 너무 모호함
```

---

## 4.4 스킬 유형

### 1. 기초 스킬 (Foundational Skills)

AI 에이전트에게 새로운 일반 능력 또는 특정 도메인에 대한 핵심 능력을 부여합니다.

**Anthropic 제공 사전 제작 스킬:**
- **PowerPoint (pptx)**: 프레젠테이션 생성, 슬라이드 편집, 발표 내용 분석
- **Excel (xlsx)**: 스프레드시트 생성, 데이터 분석, 차트가 포함된 보고서 생성
- **Word (docx)**: 문서 생성, 내용 편집, 텍스트 서식 지정
- **PDF (pdf)**: 텍스트 및 표 추출, 양식 채우기, 문서 병합

### 2. 서드파티 스킬 (Third-Party Skills)

외부 파트너사들이 자사의 소프트웨어를 AI 에이전트가 더 효과적으로 활용할 수 있도록 개발합니다.

**예시:**
- **Browserbase**: 웹 자동화 도구를 위한 스킬
- **Notion**: 워크스페이스 이해 및 리서치 스킬

### 3. 엔터프라이즈 스킬 (Enterprise Skills)

기업 및 팀별 고유의 요구사항에 맞춰 제작되는 맞춤형 스킬입니다.

**활용 사례:**
- 조직 내 고유한 업무 프로세스 교육
- 코드 스타일 가이드라인 적용
- 내부 개발 프레임워크 사용법 전달

---

## 4.5 스킬 아키텍처

### 범용 에이전트 아키텍처 구성 요소

```
┌─────────────────────────────────────────────────────────┐
│                    에이전트 루프                         │
│         (Agent Loop - 토큰 흐름 제어)                    │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│                   실행 환경                              │
│         (Runtime Environment - 격리된 작업 공간)         │
└─────────────────────────────────────────────────────────┘
                          │
            ┌─────────────┼─────────────┐
            ▼             ▼             ▼
┌───────────────┐ ┌───────────────┐ ┌───────────────┐
│  MCP 서버     │ │  스킬        │ │  파일 시스템  │
│  (외부 연결)  │ │  라이브러리  │ │  (읽기/쓰기)  │
└───────────────┘ └───────────────┘ └───────────────┘
```

### MCP와 스킬의 역할 분담

| 구성 요소 | 역할 |
|----------|------|
| **MCP 서버** | 외부 세계와의 **원시적인 연결(the 'what')** 제공 |
| **스킬** | 그 연결을 활용하여 복잡한 작업을 수행하는 **전문적인 절차(the 'how')** 제공 |

---

## 4.6 스킬 모범 사례

### 핵심 원칙 1: 간결하게 유지

```
Claude는 이미 매우 똑똑합니다.
Claude가 모르는 컨텍스트만 추가하세요.
```

**좋은 예시 (약 50토큰):**
```markdown
## Extract PDF text

Use pdfplumber for text extraction:
\`\`\`python
import pdfplumber
with pdfplumber.open("file.pdf") as pdf:
    text = pdf.pages[0].extract_text()
\`\`\`
```

**나쁜 예시 (약 150토큰):**
```markdown
## Extract PDF text

PDF (Portable Document Format) files are a common file format that contains
text, images, and other content. To extract text from a PDF, you'll need to
use a library. There are many libraries available...
```

### 핵심 원칙 2: 자유도를 적절히 설정

| 자유도 | 사용 시점 | 예시 |
|--------|----------|------|
| **높음** (텍스트 지침) | 여러 접근법이 유효할 때, 결정이 컨텍스트에 따를 때 | 코드 리뷰 프로세스 |
| **중간** (의사코드/스크립트) | 선호 패턴이 있지만 약간의 변형이 허용될 때 | 리포트 생성 템플릿 |
| **낮음** (특정 스크립트) | 작업이 취약하고 오류가 발생하기 쉬울 때 | 데이터베이스 마이그레이션 |

### 핵심 원칙 3: 피드백 루프 구현

```markdown
## Document editing process

1. Make your edits to `word/document.xml`
2. **Validate immediately**: `python ooxml/scripts/validate.py unpacked_dir/`
3. If validation fails:
   - Review the error message carefully
   - Fix the issues in the XML
   - Run validation again
4. **Only proceed when validation passes**
5. Rebuild: `python ooxml/scripts/pack.py unpacked_dir/ output.docx`
```

### 핵심 원칙 4: 점진적 공개 패턴 활용

**패턴 1: 하이레벨 가이드 + 참조**
```markdown
# PDF Processing

## Quick start
[간단한 시작 코드]

## Advanced features
**Form filling**: See [FORMS.md](FORMS.md) for complete guide
**API reference**: See [REFERENCE.md](REFERENCE.md) for all methods
```

**패턴 2: 도메인별 구성**
```
bigquery-skill/
├── SKILL.md (개요 및 네비게이션)
└── reference/
    ├── finance.md
    ├── sales.md
    └── product.md
```

### 핵심 원칙 5: 깊은 중첩 참조 피하기

```
❌ 잘못된 예시: 너무 깊음
SKILL.md → advanced.md → details.md

✅ 올바른 예시: 한 레벨 깊이
SKILL.md → advanced.md
SKILL.md → reference.md
SKILL.md → examples.md
```

---

## 4.7 피해야 할 안티패턴

| 안티패턴 | 올바른 방법 |
|---------|-----------|
| **Windows 스타일 경로** (`scripts\helper.py`) | Unix 스타일 사용 (`scripts/helper.py`) |
| **너무 많은 옵션 제공** | 기본값 제공 + 탈출구 |
| **시간에 민감한 정보** | "old patterns" 섹션으로 분리 |
| **일관성 없는 용어** | 하나의 용어를 선택하고 일관되게 사용 |
| **패키지 설치 가정** | 명시적으로 의존성 안내 |

---

## 4.8 스킬 개발 워크플로우

### 평가 중심 개발

1. **갭 식별**: 스킬 없이 대표적 작업 실행, 구체적인 실패 문서화
2. **평가 생성**: 이 갭을 테스트하는 3개 시나리오 구축
3. **기준선 설정**: 스킬 없이 Claude의 성능 측정
4. **최소 지침 작성**: 갭을 해결하고 평가를 통과할 만큼만 콘텐츠 생성
5. **반복**: 평가 실행, 기준선과 비교, 개선

### Claude와 함께 반복 개발

```
Claude A (스킬 작성자)
    │
    ▼
스킬 생성/개선
    │
    ▼
Claude B (스킬 사용자) ──► 실제 작업 테스트
    │
    ▼
관찰 및 피드백 수집
    │
    └──────────────────────► Claude A로 돌아가 개선
```

---

## 4.9 보안 고려사항

> **경고**: 스킬은 신뢰할 수 있는 출처에서만 사용하세요.

### 주요 보안 고려사항

| 위험 | 권장 조치 |
|------|----------|
| **코드 의존성** | 모든 번들된 파일(SKILL.md, 스크립트, 이미지, 기타 리소스) 철저히 감사 |
| **외부 소스** | 외부 URL에서 데이터를 가져오는 스킬은 특히 위험 |
| **도구 오용** | 악의적 스킬은 파일 작업, bash 명령, 코드 실행을 해로운 방식으로 호출 가능 |
| **데이터 노출** | 민감한 데이터에 접근하는 스킬은 정보 유출 위험 |

---

# 제5부: 통합 워크플로우 - Commands, Hooks와의 연계

## 5.1 Custom Commands (사용자 정의 명령어)

### 개념

Custom Commands는 자주 사용하는 복잡한 프롬프트를 `/명령어` 형태로 단순화합니다.

### 명령어 파일 위치 및 구조

```
.claude/
└── commands/
    ├── commit.md
    ├── prime.md
    ├── plan-feature.md
    ├── execute.md
    ├── validate.md
    └── code-review.md
```

### 명령어 예시: `/prime`

```markdown
# Project Context Loading

## 목적
새 대화 시작 시 프로젝트의 핵심 컨텍스트를 로드합니다.

## 작업 순서
1. 다음 파일들을 순서대로 읽어주세요:
   - `.claude/PRD.md` (제품 요구사항)
   - `app/doc/todo.md` (현재 진행 상황)
   - `.claude/reference/coding-conventions.md` (코딩 규약)

2. 읽은 내용을 바탕으로 현재 프로젝트 상태를 요약해주세요.

3. "프로젝트 컨텍스트가 로드되었습니다. 무엇을 도와드릴까요?"라고 질문하세요.
```

### 명령어 예시: `/commit`

```markdown
# Git Commit Message Generation

## 작업 순서
1. `git status`와 `git diff --staged`를 실행하여 변경 사항 확인
2. 변경 사항을 분석하여 커밋 메시지 작성
3. 다음 형식을 따르세요:
   - 제목: 50자 이내, 현재형 동사로 시작
   - 본문: 변경 이유와 영향 설명
4. 사용자 확인 후 커밋 실행
```

---

## 5.2 Hooks (훅)

### 개념

Hooks는 특정 이벤트에 반응하여 자동으로 실행되는 셸 명령어입니다.

### 주요 훅 유형

| 훅 유형 | 트리거 시점 |
|--------|-----------|
| `PreToolUse` | 도구 실행 전 |
| `PostToolUse` | 도구 실행 후 |
| `Notification` | 알림 발생 시 |

### 설정 예시

```json
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Edit",
        "command": "echo 'About to edit file'"
      }
    ],
    "PostToolUse": [
      {
        "matcher": "Bash",
        "command": "echo 'Command executed' >> ~/.claude/logs/bash.log"
      }
    ]
  }
}
```

---

## 5.3 하위 에이전트와 명령어/훅의 결합

### 통합 워크플로우 예시

```
사용자: /prime_tts
          │
          ▼
    1. /prime 명령어 실행
       └── 프로젝트 컨텍스트 로드
          │
          ▼
    2. TTS 요약 하위 에이전트 호출
       └── "준비가 완료되었습니다" 음성 생성
          │
          ▼
    사용자에게 음성 피드백
```

### 자동화된 다중 에이전트 워크플로우

```
사용자: "UI 개선안 제안 및 구현 후, 코드 리뷰를 받고, 피드백을 반영해 줘"
          │
          ▼
    범용 에이전트: 할 일 목록 생성
    - [ ] 프론트엔드 엔지니어: UI 개선 제안 및 구현
    - [ ] 코드 리뷰어: 변경 사항 검토
    - [ ] 프론트엔드 엔지니어: 피드백 반영 및 최종 수정
          │
          ▼
    순차적으로 @frontend-engineer → @code-reviewer → @frontend-engineer 호출
          │
          ▼
    전체 작업 자동 완료
```

---

## 5.4 메타 프로그래밍: 에이전트를 구축하는 에이전트

### 개념

가장 강력한 패턴 중 하나는 '메타 에이전트(Meta-Agent)', 즉 다른 에이전트를 생성하는 에이전트를 구축하는 것입니다.

### 올바른 접근 순서

```
1. 문제 정의
   └── "에이전트 작업을 대규모로 실행할 때, 어떤 에이전트가
       언제 작업을 완료했는지 추적하기 어렵다."

2. 해결책 구상
   └── "각 에이전트가 작업 완료 시점과 수행 내용을
       음성(TTS)으로 알려주도록 하자."

3. 기술 적용
   └── "이 TTS 알림 기능을 수행하는 새로운 하위 에이전트를
       '메타 에이전트'를 통해 생성한다."
```

### 핵심 원칙

> **'문제 → 해결책 → 기술'**의 순서로 접근해야 합니다.
> 기술에서부터 시작하는 것은 초보적인 접근 방식이며,
> 실제 가치를 창출하지 못하는 솔루션으로 이어지기 쉽습니다.

---

# 제6부: 결론 및 권고사항

## 6.1 핵심 요약

### Big Three 원칙

궁극적으로 스케일업의 핵심은 개별 기술의 숙련도보다, 시스템 전체 관점에서 신호를 포착하고 노이즈를 제거하는 능력에 있습니다. 그 신호의 중심에는 세 가지 핵심 요소가 있습니다:

```
┌───────────────────────────────────────────────────────┐
│                    Big Three 원칙                      │
│                                                        │
│    ┌───────────┐  ┌───────────┐  ┌───────────┐       │
│    │ 컨텍스트  │──│   모델    │──│  프롬프트  │       │
│    │ (Context) │  │  (Model)  │  │ (Prompt)  │       │
│    └───────────┘  └───────────┘  └───────────┘       │
│                                                        │
│    이 세 가지 요소의 흐름을 시스템 전체 관점에서         │
│    이해하고 제어하는 능력이 가장 중요합니다.             │
└───────────────────────────────────────────────────────┘
```

### 컴퓨팅 패러다임과의 비유

| AI 시대 | 컴퓨팅 역사 |
|--------|-----------|
| 모델 (Models) | 프로세서 (Processors) |
| 에이전트 런타임 (Agent Runtime) | 운영체제 (Operating System) |
| 스킬 (Skills) | 애플리케이션 (Applications) |

> 소수의 기업이 프로세서와 운영체제를 만들지만, 수백만 명의 개발자들이 그 위에 자신들의 도메인 전문성과 독창적인 아이디어를 담은 '애플리케이션'을 만들어 세상을 바꾸었습니다.

---

## 6.2 실행 권고사항

### 즉시 적용 가능한 3단계 전략

| 단계 | 권고사항 |
|------|----------|
| **1. 역할 분리** | 모든 직접적인 코드 구현 및 수정은 상위 에이전트에게 전담. 하위 에이전트에게는 연구 지향적인 작업만 위임 |
| **2. 컨텍스트 외부화** | 파일 시스템을 '단일 진실 공급원(Source of Truth)'으로 사용하여 모든 에이전트 간의 컨텍스트를 명시적으로 공유 |
| **3. 구현 중앙화** | 모든 코드 작성 및 수정은 전체 프로젝트 컨텍스트를 파악하고 있는 상위 에이전트가 전담 |

### 스킬 도입을 위한 권고사항

| 권고사항 | 설명 |
|---------|------|
| **소프트웨어 자산으로 취급** | 테스트, 평가, 버전 관리 및 의존성 관리가 필요한 핵심 자산으로 인식 |
| **측정 및 평가 시스템 구축** | 스킬을 장착한 에이전트가 의도한 작업을 정확히 수행하는지 측정 |
| **공유 및 배포 문화 조성** | 우수한 스킬이 전사적으로 쉽게 공유되고 재사용될 수 있는 플랫폼 구축 |

---

## 6.3 미래 전망

### 개발자 역할의 진화

개발자의 역할은 더 이상 한 줄 한 줄 코드를 작성하는 '코드 작성자'에 머무르지 않습니다. 대신:

```
┌─────────────────────────────────────────────────────────┐
│                    새로운 개발자 역할                    │
│                                                         │
│    • AI 시스템 설계자                                    │
│    • 워크플로우 오케스트레이터                           │
│    • 전문화된 AI 에이전트 팀의 지휘자                    │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 학습하는 조직으로의 전환

스킬의 진정한 가치는 개별 에이전트를 똑똑하게 만드는 것을 넘어 **조직의 집단 지성을 강화하는 매개체**입니다. 에이전트가 사용자와 상호작용하며 피드백과 제도적 지식을 얻고, 이를 바탕으로 스스로 새로운 스킬을 생성하거나 기존 스킬을 개선하는 선순환 구조를 만드는 것입니다.

> "당신과 함께 일한 지 30일째 되는 Claude는 첫날보다 훨씬 더 나을 것입니다."

---

## 6.4 마무리

```
"에이전트를 재구축하는 것을 멈추고,
 대신 스킬을 구축하기 시작할 때입니다."

"It's time to stop rebuilding agents
 and start building skills instead."
```

이 기술들을 여러분의 작업 방식에 적용하는 것은 단순히 몇 가지 팁을 배우는 것을 넘어, **AI와 함께 일하는 방식을 근본적으로 개선하고 장기적으로 더 나은 결과를 만들어내는 위대한 여정의 시작**입니다.

이 흐름을 마스터하는 엔지니어는 단순한 코더를 넘어, **자동화와 지능의 시대를 선도하는 진정한 빌더(builder)**가 될 것입니다.

---

# 참고 자료

## 공식 문서
- [Agent Skills Overview](https://platform.claude.com/docs/en/agents-and-tools/agent-skills/overview)
- [Agent Skills Best Practices](https://platform.claude.com/docs/en/agents-and-tools/agent-skills/best-practices)
- [Agent Skills Quickstart](https://platform.claude.com/docs/en/agents-and-tools/agent-skills/quickstart)
- [Skills Cookbook](https://platform.claude.com/cookbook/skills-notebooks-01-skills-introduction)

## 블로그 및 기술 문서
- [Equipping agents for the real world with Agent Skills](https://www.anthropic.com/engineering/equipping-agents-for-the-real-world-with-agent-skills)

---

*이 문서는 Claude Code의 Skills, Custom Commands, Sub-Agents, Hooks에 대한 R&D 내용을 종합적으로 정리한 것입니다.*
